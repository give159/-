# 🎯 IPOから完成まで - 完全ステップガイド

プログラム設計の基本「IPO（Input-Process-Output）」から実装完成まで、新人エンジニア向けに徹底解説します。

---

## 📋 目次

1. [IPO分析](#ステップ1-ipo分析)
2. [要件定義](#ステップ2-要件定義)
3. [クラス設計](#ステップ3-クラス設計)
4. [データ構造設計](#ステップ4-データ構造設計)
5. [メソッド設計](#ステップ5-メソッド設計)
6. [実装順序の決定](#ステップ6-実装順序の決定)
7. [段階的実装](#ステップ7-段階的実装)
8. [テスト](#ステップ8-テスト)
9. [デバッグ](#ステップ9-デバッグ)
10. [完成・リファクタリング](#ステップ10-完成リファクタリング)

---

## ステップ1: IPO分析

### 🤔 IPOとは？

```
I (Input)   - 入力：何を受け取るか？
P (Process) - 処理：何をするか？
O (Output)  - 出力：何を返すか？
```

### 📊 社員管理システムのIPO分析

#### 全体のIPO

```
┌──────────────────────────────────────────┐
│           社員管理システム                │
├──────────────────────────────────────────┤
│ Input (入力)                             │
│ ・社員情報（名前、給料、部署）            │
│ ・社長情報（名前、給料）                  │
│ ・操作コマンド（追加、削除、表示）        │
├──────────────────────────────────────────┤
│ Process (処理)                           │
│ ・社員の登録                             │
│ ・社員の解雇                             │
│ ・情報の管理                             │
│ ・社員数の計算                           │
├──────────────────────────────────────────┤
│ Output (出力)                            │
│ ・社員一覧                               │
│ ・社長情報                               │
│ ・解雇通知                               │
│ ・社員数                                 │
└──────────────────────────────────────────┘
```

#### 各機能のIPO

**機能1: 社員登録**
```
Input:  名前、給料、部署
Process: 社員オブジェクトを作成してリストに追加
Output: なし（内部状態の変更のみ）
```

**機能2: 社員解雇**
```
Input:  解雇する社員の名前
Process: リストから該当社員を削除
Output: 解雇通知メッセージ、現在の社員数
```

**機能3: 情報表示**
```
Input:  なし
Process: 社員リストを走査
Output: 各社員の情報（名前、給料、部署）
```

**機能4: 社長情報取得**
```
Input:  なし
Process: 社長オブジェクトから情報を取得
Output: 社長の名前（「社長」付き）、給料
```

---

## ステップ2: 要件定義

### 📝 機能要件

#### 必須機能
- ✅ 社員情報の管理（名前、給料、部署）
- ✅ 社長情報の管理（名前、給料、肩書き）
- ✅ 社員の追加
- ✅ 社員の解雇（2つの方法）
  - 社長による解雇（dismiss）
  - 会社による解雇手続き（set_dismissal_procedure）
- ✅ 情報の表示
- ✅ 社員数のカウント（社長含む）

#### 非機能要件
- ✅ クラス分割（保守性）
- ✅ 継承の活用（再利用性）
- ✅ プロパティの使用（可読性）
- ✅ デコレータの使用（機能拡張性）
- ✅ デストラクタの実装（リソース管理）
- ✅ Docstring（ドキュメント性）

### 📊 制約条件

```
・各クラスは別ファイルに分ける
・Employeeを基底クラスとする
・StaffとPresidentはEmployeeを継承
・Presidentのget_name()はオーバーライド
・Companyのstaffs、ceoはプロパティ
・社員数表示はデコレータで実装
```

---

## ステップ3: クラス設計

### 🏗️ クラス図

```
        ┌─────────────┐
        │  Employee   │ ← 基底クラス
        ├─────────────┤
        │ - _name     │
        │ - _salary   │
        ├─────────────┤
        │ + get_name()│
        │ + set_name()│
        │ + get/set   │
        │   _salary   │
        └─────────────┘
               ▲
               │ 継承
       ┌───────┴───────┐
       │               │
┌──────┴────┐   ┌──────┴────────┐
│   Staff   │   │  President    │
├───────────┤   ├───────────────┤
│-_division │   │ - _company    │
├───────────┤   ├───────────────┤
│+ get/set  │   │+ get_name()   │← オーバーライド
│  _division│   │+ dismiss()    │
└───────────┘   └───────────────┘
                       ▲
                       │ 参照
                       │
                ┌──────┴────────┐
                │    Company    │
                ├───────────────┤
                │ - _staffs     │
                │ - _ceo        │
                ├───────────────┤
                │ + staffs      │← プロパティ
                │ + ceo         │← プロパティ
                │ + set_dismissal│
                │   _procedure  │
                └───────────────┘
```

### 🎯 クラスの責務

| クラス | 責務（役割） |
|--------|------------|
| **Employee** | 社員の基本情報を管理 |
| **Staff** | 一般社員の情報を管理（部署追加） |
| **President** | 社長の情報と解雇権限を管理 |
| **Company** | 全社員と社長を統括管理 |

---

## ステップ4: データ構造設計

### 📊 データモデル

#### Employee（基底）
```python
{
    "_name": str,      # 名前
    "_salary": int     # 給料
}
```

#### Staff（Employee継承）
```python
{
    "_name": str,      # ← 継承
    "_salary": int,    # ← 継承
    "_division": str   # 部署（追加）
}
```

#### President（Employee継承）
```python
{
    "_name": str,      # ← 継承
    "_salary": int,    # ← 継承
    "_company": Company # 会社への参照（追加）
}
```

#### Company
```python
{
    "_staffs": List[Staff],    # 社員リスト
    "_ceo": President          # 社長
}
```

### 🔗 関連図

```
Company
  ├─ _staffs (List)
  │    ├─ Staff1 (名前、給料、部署)
  │    ├─ Staff2 (名前、給料、部署)
  │    └─ Staff3 (名前、給料、部署)
  │
  └─ _ceo (President)
       ├─ 名前
       ├─ 給料
       └─ _company ──┐
            ↑        │
            └────────┘ (循環参照)
```

---

## ステップ5: メソッド設計

### 📝 各クラスのメソッド一覧

#### Employee
```
┌─────────────────────────────────┐
│ Employee                        │
├─────────────────────────────────┤
│ __init__()                      │ コンストラクタ
│ get_name() -> str               │ 名前取得
│ set_name(name: str)             │ 名前設定
│ get_salary() -> int             │ 給料取得
│ set_salary(salary: int)         │ 給料設定
│ __del__()                       │ デストラクタ
└─────────────────────────────────┘
```

#### Staff
```
┌─────────────────────────────────┐
│ Staff                           │
├─────────────────────────────────┤
│ __init__()                      │ コンストラクタ
│ ↑ 親のメソッド全て継承          │
│ get_division() -> str           │ 部署取得
│ set_division(div: str)          │ 部署設定
│ __del__()                       │ デストラクタ（上書き）
└─────────────────────────────────┘
```

#### President
```
┌─────────────────────────────────┐
│ President                       │
├─────────────────────────────────┤
│ __init__(company: Company)      │ コンストラクタ
│ ↑ 親のメソッド全て継承          │
│ get_name() -> str               │ オーバーライド
│ dismiss(name: str)              │ 解雇処理
│ __del__()                       │ デストラクタ（上書き）
└─────────────────────────────────┘
```

#### Company
```
┌─────────────────────────────────┐
│ Company                         │
├─────────────────────────────────┤
│ __init__()                      │ コンストラクタ
│ @property staffs                │ 社員リスト取得
│ @property ceo                   │ 社長取得
│ @decorator                      │
│ set_dismissal_procedure(name)   │ 解雇手続き
│ __del__()                       │ デストラクタ
└─────────────────────────────────┘
```

### 🔍 メソッドのIPO詳細

**Employee.set_name()**
```
Input:  emp_name (str)
Process: self._name = emp_name
Output: None
```

**President.get_name()**
```
Input:  なし
Process: self._name + "社長"
Output: str（肩書き付きの名前）
```

**President.dismiss()**
```
Input:  name (str)
Process: リスト内包表記で該当者を除外
Output: None（print文で通知）
```

**Company.set_dismissal_procedure()**
```
Input:  name (str)
Process: 
  1. リスト内包表記で該当者を除外
  2. デコレータが社員数を計算・表示
Output: None（print文で通知）
```

---

## ステップ6: 実装順序の決定

### 🎯 なぜ順序が重要？

```
理由1: 依存関係
  → 親クラスがないと子クラスが作れない

理由2: テストのしやすさ
  → 小さい部品から作ると確認しやすい

理由3: エラーの特定
  → 段階的に作ると問題箇所がわかりやすい
```

### 📅 推奨実装順序

```
Phase 1: 基礎クラス（依存なし）
  └─ Step 1: employee.py を作成

Phase 2: 継承クラス（Employee依存）
  ├─ Step 2: staff.py を作成
  └─ Step 3: president.py を作成（仮実装）

Phase 3: 管理クラス（全クラス依存）
  └─ Step 4: company.py を作成

Phase 4: メイン処理
  └─ Step 5: main.py を作成

Phase 5: 高度な機能
  ├─ Step 6: デコレータ実装
  └─ Step 7: デストラクタ確認

Phase 6: テスト
  └─ Step 8: テストファイル作成
```

---

## ステップ7: 段階的実装

### 🏗️ Phase 1: Employee（基礎）

#### Step 1-1: 最小構成
```python
class Employee:
    def __init__(self):
        self._name = ""
        self._salary = 0
```

#### Step 1-2: getter/setter追加
```python
def get_name(self):
    return self._name

def set_name(self, emp_name):
    self._name = emp_name
```

#### Step 1-3: 型ヒント追加
```python
def get_name(self) -> str:
    return self._name

def set_name(self, emp_name: str) -> None:
    self._name = emp_name
```

#### Step 1-4: Docstring追加
```python
def get_name(self) -> str:
    """
    社員の名前を取得する
    
    Returns:
        str: 社員の名前
    """
    return self._name
```

#### Step 1-5: デストラクタ追加
```python
def __del__(self):
    print(f"[デストラクタ] Employee '{self._name}' が削除されました")
```

#### ✅ テスト
```python
# 簡易テスト
emp = Employee()
emp.set_name("テスト太郎")
print(emp.get_name())  # "テスト太郎" が出力されるはず
```

---

### 🏗️ Phase 2: Staff（継承）

#### Step 2-1: 継承の基本
```python
from employee import Employee

class Staff(Employee):
    def __init__(self):
        super().__init__()  # ← 重要！
```

#### Step 2-2: 独自変数追加
```python
def __init__(self):
    super().__init__()
    self._division = ""
```

#### Step 2-3: getter/setter追加
```python
def get_division(self) -> str:
    return self._division

def set_division(self, emp_division: str) -> None:
    self._division = emp_division
```

#### ✅ テスト
```python
staff = Staff()
staff.set_name("佐藤太郎")  # 親のメソッド
staff.set_division("営業部")  # 自分のメソッド
print(f"{staff.get_name()} - {staff.get_division()}")
```

---

### 🏗️ Phase 3: President（オーバーライド）

#### Step 3-1: 基本構造
```python
from employee import Employee

class President(Employee):
    def __init__(self, company):
        super().__init__()
        self._company = company
```

#### Step 3-2: オーバーライド
```python
def get_name(self) -> str:
    return self._name + "社長"
```

#### Step 3-3: 解雇メソッド
```python
def dismiss(self, name: str) -> None:
    self._company._staffs = [
        staff for staff in self._company._staffs 
        if staff.get_name() != name
    ]
    print(f"[解雇通知] {name}さんを解雇しました")
```

#### ✅ テスト
```python
# 簡易的な会社クラスでテスト
class TestCompany:
    def __init__(self):
        self._staffs = []
        self._ceo = President(self)

company = TestCompany()
company._ceo.set_name("社長太郎")
print(company._ceo.get_name())  # "社長太郎社長" が出力されるはず
```

---

### 🏗️ Phase 4: Company（統合）

#### Step 4-1: 基本構造
```python
from typing import List
from staff import Staff
from president import President

class Company:
    def __init__(self):
        self._staffs: List[Staff] = []
        self._ceo: President = President(self)
```

#### Step 4-2: プロパティ追加
```python
@property
def staffs(self) -> List[Staff]:
    return self._staffs

@property
def ceo(self) -> President:
    return self._ceo
```

#### Step 4-3: 解雇手続きメソッド（デコレータなし）
```python
def set_dismissal_procedure(self, name: str) -> None:
    self._staffs = [
        staff for staff in self._staffs 
        if staff.get_name() != name
    ]
    print(f"[解雇手続き完了] {name}さんの解雇手続きが完了しました")
```

#### ✅ テスト
```python
company = Company()

# 社員追加
staff1 = Staff()
staff1.set_name("佐藤太郎")
company.staffs.append(staff1)

# 確認
print(f"社員数: {len(company.staffs)}")  # 1 が出力されるはず
```

---

### 🏗️ Phase 5: デコレータ（高度な機能）

#### Step 5-1: デコレータ定義
```python
from functools import wraps

def print_employee_count(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        total_employees = len(self._staffs) + 1
        print(f"現在わが社の社員数は{total_employees}人になっています")
        return result
    return wrapper
```

#### Step 5-2: デコレータ適用
```python
@print_employee_count
def set_dismissal_procedure(self, name: str) -> None:
    # ... 既存のコード
```

#### ✅ テスト
```python
company = Company()
staff1 = Staff()
staff1.set_name("佐藤太郎")
company.staffs.append(staff1)

company.set_dismissal_procedure("佐藤太郎")
# 「現在わが社の社員数は1人になっています」が出力されるはず
```

---

### 🏗️ Phase 6: メイン処理

#### Step 6-1: main.py作成
```python
from company import Company
from staff import Staff

def main():
    print("=" * 60)
    print("社員管理システム")
    print("=" * 60)
    
    company = Company()
    
    # 社員追加
    staff1 = Staff()
    staff1.set_name("佐藤太郎")
    staff1.set_salary(200000)
    staff1.set_division("営業部")
    company.staffs.append(staff1)
    
    # 情報表示
    for staff in company.staffs:
        print(f"名前：{staff.get_name()}、"
              f"給料：{staff.get_salary()}円、"
              f"所属：{staff.get_division()}")

if __name__ == "__main__":
    main()
```

#### ✅ テスト
```bash
python main.py
```

---

## ステップ8: テスト

### 🧪 テストの種類

```
1. 単体テスト（Unit Test）
   → 各クラス・メソッドを個別にテスト

2. 統合テスト（Integration Test）
   → クラス同士の連携をテスト

3. シナリオテスト
   → 実際の使用シーンをテスト
```

### 📝 テストチェックリスト

#### Employee
- [ ] インスタンス作成
- [ ] 名前の設定・取得
- [ ] 給料の設定・取得
- [ ] 初期値の確認

#### Staff
- [ ] 継承の確認
- [ ] 部署の設定・取得
- [ ] 親のメソッドが使えるか

#### President
- [ ] オーバーライドの確認
- [ ] 会社への参照
- [ ] 解雇処理

#### Company
- [ ] プロパティのアクセス
- [ ] 社員の追加
- [ ] 解雇手続き
- [ ] デコレータの動作

---

## ステップ9: デバッグ

### 🐛 デバッグ手法

#### 1. print()デバッグ
```python
def dismiss(self, name: str):
    print(f"[DEBUG] 解雇対象: {name}")
    print(f"[DEBUG] 現在の社員: {[s.get_name() for s in self._company._staffs]}")
    
    # 処理
    
    print(f"[DEBUG] 解雇後の社員: {[s.get_name() for s in self._company._staffs]}")
```

#### 2. type()で型確認
```python
print(f"[DEBUG] type: {type(company.staffs)}")
```

#### 3. dir()でメソッド確認
```python
print(f"[DEBUG] methods: {dir(staff)}")
```

#### 4. assert文でチェック
```python
assert len(company.staffs) == 2, "社員数が正しくありません"
```

### 📋 デバッグチェックリスト

- [ ] エラーメッセージを読む
- [ ] エラーが起きた行を確認
- [ ] 変数の値を確認
- [ ] 型を確認
- [ ] メソッドの戻り値を確認
- [ ] 条件分岐の動作を確認

---

## ステップ10: 完成・リファクタリング

### ✨ 完成の基準

```
✅ すべての要件を満たしている
✅ テストがすべて通る
✅ エラーが出ない
✅ 期待通りの出力がされる
✅ コードが読みやすい
✅ Docstringが書かれている
```

### 🔧 リファクタリング

#### 改善ポイント1: マジックナンバーを定数化
```python
# Before
if salary < 0:
    raise ValueError("給料は0以上")

# After
MIN_SALARY = 0
if salary < MIN_SALARY:
    raise ValueError(f"給料は{MIN_SALARY}以上")
```

#### 改善ポイント2: 長いメソッドを分割
```python
# Before
def process(self):
    # 50行の処理

# After
def process(self):
    self._validate()
    self._calculate()
    self._display()

def _validate(self):
    # バリデーション

def _calculate(self):
    # 計算

def _display(self):
    # 表示
```

#### 改善ポイント3: エラーハンドリング追加
```python
def set_salary(self, emp_salary: int) -> None:
    if emp_salary < 0:
        raise ValueError("給料は0以上である必要があります")
    self._salary = emp_salary
```

---

## 🎓 まとめ

### 開発の流れ（全体像）

```
IPO分析
  ↓
要件定義
  ↓
クラス設計
  ↓
データ構造設計
  ↓
メソッド設計
  ↓
実装順序決定
  ↓
段階的実装
  ├─ Employee
  ├─ Staff
  ├─ President
  ├─ Company
  └─ main
  ↓
テスト
  ↓
デバッグ
  ↓
完成・リファクタリング
```

### 重要ポイント

1. **最初に全体を設計する**
   - IPOで整理
   - クラス図を描く

2. **小さく作って確認**
   - 1つずつ実装
   - こまめにテスト

3. **依存関係を意識**
   - 親→子の順
   - 基礎→応用の順

4. **エラーを恐れない**
   - エラーは成長のチャンス
   - デバッグ力が付く

---

**これであなたも立派なPythonエンジニアです！🎉**
