# 🎬 プログラムの実行フロー完全解説

コードが**どの順番で**、**何をしているか**を1ステップずつ追跡します。

---

## 📍 実行開始: `python main.py`

---

### ステップ1: インポートフェーズ

```python
from company import Company
from staff import Staff
```

#### 🔍 内部で起こること

**1-1. `from staff import Staff` の実行**

```
main.py
  └→ staff.py を読み込む
      └→ from employee import Employee を実行
          └→ employee.py を読み込む
              └→ Employee クラスを定義
          ← Employee クラスが使えるようになる
      └→ class Staff(Employee): を実行
          └→ Staff クラスを定義
      ← Staff クラスが使えるようになる
```

**1-2. `from company import Company` の実行**

```
main.py
  └→ company.py を読み込む
      └→ from staff import Staff を実行（既に読み込み済み）
      └→ from president import President を実行
          └→ president.py を読み込む
              └→ Employee を継承
              └→ President クラスを定義
          ← President クラスが使えるようになる
      └→ def print_employee_count(func): を実行
          └→ デコレータ関数を定義
      └→ class Company: を実行
          └→ Company クラスを定義
      ← Company クラスが使えるようになる
```

---

### ステップ2: main()関数の定義

```python
def main():
    # ...
```

#### 🔍 内部で起こること

- main という名前の関数を定義（まだ実行されない）
- 中身は後で実行される

---

### ステップ3: エントリーポイントの実行

```python
if __name__ == "__main__":
    main()
```

#### 🔍 内部で起こること

```
1. __name__ を確認
   - 直接実行された場合: __name__ == "__main__"
   - インポートされた場合: __name__ == "main"
   
2. 条件が True なので main() を実行
```

---

### ステップ4: main()関数の実行開始

```python
def main():
    print("=" * 60)
    print("社員管理システム テスト開始")
    print("=" * 60)
    print()
```

#### 🔍 出力

```
============================================================
社員管理システム テスト開始
============================================================

```

---

### ステップ5: Companyインスタンスの作成

```python
company = Company()
```

#### 🔍 内部で起こること（詳細）

**5-1. Company.__init__() が呼ばれる**

```python
def __init__(self):
    self._staffs: List[Staff] = []  # ← まずこれを実行
```

📊 **メモリの状態（設定後）:**
```
staff1 オブジェクト（Staff）
├─ _name = "佐藤太郎"
├─ _salary = 200000
└─ _division = "営業部"
```

**6-4. リストに追加**

```python
company.staffs.append(staff1)
```

内部処理:
```python
@property
def staffs(self):
    return self._staffs  # ← リストを取得

# append() はリストのメソッド
self._staffs.append(staff1)
```

📊 **メモリの状態:**
```
company オブジェクト
├─ _staffs = [staff1]  ← staff1 が追加された
└─ _ceo = President オブジェクト
```

---

### ステップ7: 社員2の作成（同様の処理）

```python
staff2 = Staff()
staff2.set_name("鈴木次郎")
staff2.set_salary(300000)
staff2.set_division("開発部")
company.staffs.append(staff2)
```

📊 **メモリの状態:**
```
company オブジェクト
├─ _staffs = [staff1, staff2]  ← 2人になった
└─ _ceo = President オブジェクト

staff1: 佐藤太郎, 200000円, 営業部
staff2: 鈴木次郎, 300000円, 開発部
```

---

### ステップ8: 社長の設定

```python
company.ceo.set_name("偉井杉人")
```

#### 🔍 内部で起こること

**8-1. プロパティを通じてアクセス**

```python
@property
def ceo(self):
    return self._ceo  # ← President オブジェクトを取得
```

**8-2. set_name() を呼ぶ**

```python
def set_name(self, emp_name: str):
    self._name = emp_name  # ← "偉井杉人" を代入
```

```python
company.ceo.set_salary(2500000)
```

📊 **メモリの状態:**
```
company._ceo オブジェクト
├─ _name = "偉井杉人"
├─ _salary = 2500000
└─ _company = company
```

---

### ステップ9: 社員情報の表示

```python
print("【社員一覧】")
for staff in company.staffs:
    print(f"名前：{staff.get_name()}、給料：{staff.get_salary()}円、所属：{staff.get_division()}")
```

#### 🔍 内部で起こること（ループ1回目）

**9-1. for ループ開始**

```
company.staffs を取得
  ↓
[staff1, staff2] を取得
  ↓
staff1 を staff 変数に代入
```

**9-2. staff.get_name() を呼ぶ**

```python
def get_name(self):
    return self._name  # ← "佐藤太郎" を返す
```

**9-3. staff.get_salary() を呼ぶ**

```python
def get_salary(self):
    return self._salary  # ← 200000 を返す
```

**9-4. staff.get_division() を呼ぶ**

```python
def get_division(self):
    return self._division  # ← "営業部" を返す
```

**9-5. f-string で文字列を作成**

```python
f"名前：{staff.get_name()}、給料：{staff.get_salary()}円、所属：{staff.get_division()}"
↓
"名前：佐藤太郎、給料：200000円、所属：営業部"
```

#### 🔍 出力

```
【社員一覧】
名前：佐藤太郎、給料：200000円、所属：営業部
名前：鈴木次郎、給料：300000円、所属：開発部
```

---

### ステップ10: 社長情報の表示

```python
print(f"名前：{company.ceo.get_name()}、給料：{company.ceo.get_salary()}円")
```

#### 🔍 内部で起こること（重要！）

**10-1. company.ceo.get_name() を呼ぶ**

```python
# President の get_name() が呼ばれる（オーバーライドされている）
def get_name(self) -> str:
    return self._name + "社長"  # ← "偉井杉人" + "社長"
```

📌 **ポイント: オーバーライド**
- Employee の get_name() ではなく
- President の get_name() が呼ばれる
- 結果: "偉井杉人社長" が返される

#### 🔍 出力

```
【社長情報】
名前：偉井杉人社長、給料：2500000円
```

---

### ステップ11: プログラム終了

```python
if __name__ == "__main__":
    main()
    print("\n[プログラム終了 - デストラクタが呼ばれます]")
```

#### 🔍 内部で起こること

**11-1. main() から戻る**

**11-2. 終了メッセージを表示**

```
[プログラム終了 - デストラクタが呼ばれます]
```

**11-3. プログラム終了**

---

### ステップ12: デストラクタの呼び出し

プログラムが終了する際、すべてのオブジェクトが削除されます。

#### 🔍 デストラクタの実行順序

```
1. ローカル変数（main関数内）が削除される
   
   staff2.__del__() 呼ばれる
   ↓
   [デストラクタ] Staffインスタンス '鈴木次郎' が削除されました
   
   staff1.__del__() 呼ばれる
   ↓
   [デストラクタ] Staffインスタンス '佐藤太郎' が削除されました
   
   company.__del__() 呼ばれる
   ↓
   [デストラクタ] Companyインスタンスが削除されました
   
   company._ceo.__del__() 呼ばれる
   ↓
   [デストラクタ] Presidentインスタンス '偉井杉人' が削除されました
```

---

## 🎬 解雇処理の動作フロー

もし解雇処理を実行した場合の動作を見てみましょう。

```python
company.ceo.dismiss("佐藤太郎")
```

### 🔍 内部で起こること

**ステップ1: メソッド呼び出し**

```python
def dismiss(self, name: str) -> None:
```

引数: `name = "佐藤太郎"`

**ステップ2: リスト内包表記の実行**

```python
self._company._staffs = [
    staff 
    for staff in self._company._staffs 
    if staff.get_name() != name
]
```

詳細な動作:

```
元のリスト: [staff1, staff2]

ループ1回目:
  staff = staff1
  staff.get_name() = "佐藤太郎"
  "佐藤太郎" != "佐藤太郎" → False
  ↓ リストに含めない

ループ2回目:
  staff = staff2
  staff.get_name() = "鈴木次郎"
  "鈴木次郎" != "佐藤太郎" → True
  ↓ リストに含める

新しいリスト: [staff2]
```

📊 **メモリの変化:**
```
実行前:
company._staffs = [staff1, staff2]

実行後:
company._staffs = [staff2]
staff1 への参照がなくなる
  ↓
staff1.__del__() が呼ばれる
  ↓
[デストラクタ] Staffインスタンス '佐藤太郎' が削除されました
```

**ステップ3: メッセージ表示**

```python
print(f"[解雇通知] {name}さんを解雇しました")
```

出力:
```
[解雇通知] 佐藤太郎さんを解雇しました
```

---

## 🎬 デコレータ付き解雇処理の動作フロー

```python
company.set_dismissal_procedure("鈴木次郎")
```

### 🔍 内部で起こること（詳細）

**ステップ1: デコレータの wrapper が呼ばれる**

```python
@print_employee_count  # ← このデコレータが適用されている
def set_dismissal_procedure(self, name: str):
    ...
```

実際に呼ばれるのは:
```python
def wrapper(self, *args, **kwargs):
    result = func(self, *args, **kwargs)  # ← 元の関数を実行
    total_employees = len(self._staffs) + 1
    print(f"現在わが社の社員数は{total_employees}人になっています")
    return result
```

**ステップ2: 元の関数を実行**

```python
result = func(self, *args, **kwargs)
  ↓
def set_dismissal_procedure(self, name: str):
    self._staffs = [
        staff for staff in self._staffs 
        if staff.get_name() != name
    ]
    print(f"[解雇手続き完了] {name}さんの解雇手続きが完了しました")
```

解雇処理:
```
元のリスト: [staff1, staff2]
name = "鈴木次郎"
  ↓
新しいリスト: [staff1]  # 鈴木次郎が削除された
```

出力:
```
[解雇手続き完了] 鈴木次郎さんの解雇手続きが完了しました
```

**ステップ3: デコレータの後処理**

```python
total_employees = len(self._staffs) + 1
# len([staff1]) + 1 = 1 + 1 = 2

print(f"現在わが社の社員数は{total_employees}人になっています")
```

出力:
```
現在わが社の社員数は2人になっています
```

📌 **ポイント:**
- 社員1人（staff1）+ 社長1人 = 合計2人

---

## 🧠 メモリの変化を図で理解

### 初期状態（company作成直後）

```
┌─────────────────────────────────┐
│ company (Company)               │
│ ├─ _staffs = []                 │
│ └─ _ceo ────────┐               │
└─────────────────│───────────────┘
                  │
                  ↓
        ┌─────────────────────┐
        │ President           │
        │ ├─ _name = ""       │
        │ ├─ _salary = 0      │
        │ └─ _company ────────┼──┐
        └─────────────────────┘  │
                 ↑                │
                 └────────────────┘
                 （循環参照）
```

### 社員追加後

```
┌─────────────────────────────────┐
│ company (Company)               │
│ ├─ _staffs = [staff1, staff2]   │
│ └─ _ceo ────────┐               │
└─────────────────│───────────────┘
                  │
        ┌─────────┴─────┐
        ↓               ↓
┌──────────────┐ ┌──────────────┐
│ staff1       │ │ staff2       │
│ (Staff)      │ │ (Staff)      │
├──────────────┤ ├──────────────┤
│_name="佐藤"  │ │_name="鈴木"  │
│_salary=20万  │ │_salary=30万  │
│_division=    │ │_division=    │
│  "営業部"    │ │  "開発部"    │
└──────────────┘ └──────────────┘
```

### 解雇後（佐藤太郎を解雇）

```
┌─────────────────────────────────┐
│ company (Company)               │
│ ├─ _staffs = [staff2]           │
│ └─ _ceo                         │
└─────────────────────────────────┘
        
        ┌──────────────┐
        │ staff2       │
        │ (Staff)      │
        ├──────────────┤
        │_name="鈴木"  │
        │_salary=30万  │
        │_division=    │
        │  "開発部"    │
        └──────────────┘

┌──────────────┐
│ staff1       │ ← 参照がなくなった
│ (削除)       │    ので削除される
└──────────────┘    __del__が呼ばれる
```

---

## 🎯 重要なポイントまとめ

### 1. 実行順序

```
インポート → クラス定義 → main()実行 → オブジェクト作成 → メソッド呼び出し → デストラクタ
```

### 2. オブジェクト作成時

```
子クラスのコンストラクタ
  ↓
super().__init__()
  ↓
親クラスのコンストラクタ
  ↓
子クラスの独自初期化
```

### 3. メソッド呼び出し時

```
まず子クラスで探す
  ↓
なければ親クラスで探す
  ↓
見つかったメソッドを実行
```

### 4. プロパティアクセス時

```
obj.property
  ↓
@property デコレータが付いたメソッドを呼ぶ
  ↓
値を返す（()なし）
```

### 5. デコレータ実行時

```
@decorator
def func():
    pass
  ↓
実際に実行されるのは wrapper
  ↓
wrapper の中で元の func を呼ぶ
  ↓
前後に処理を追加できる
```

---

## 📚 用語と概念の整理

| 用語 | タイミング | 回数 |
|------|-----------|------|
| **インポート** | プログラム開始時 | 1回 |
| **クラス定義** | インポート時 | 1回 |
| **コンストラクタ** | インスタンス作成時 | 1回/インスタンス |
| **メソッド** | 明示的に呼び出した時 | 何度でも |
| **プロパティ** | アクセス時（自動） | 何度でも |
| **デコレータ** | メソッド呼び出し時（自動） | 呼び出しごと |
| **デストラクタ** | インスタンス削除時 | 1回/インスタンス |

---

これでプログラムの実行フローが完全に理解できましたね！🎉リの状態:**
```
company オブジェクト
├─ _staffs = []  ← 空のリスト
└─ _ceo = ?      ← まだ作られていない
```

**5-2. President インスタンスを作成**

```python
self._ceo: President = President(self)  # ← 次にこれを実行
```

**5-3. President.__init__() が呼ばれる**

```python
def __init__(self, company: 'Company'):
    super().__init__()  # ← Employee.__init__() を呼ぶ
```

**5-4. Employee.__init__() が呼ばれる**

```python
def __init__(self):
    self._name: str = ""
    self._salary: int = 0
```

📊 **メモリの状態:**
```
company._ceo オブジェクト（President）
├─ _name = ""      ← Employee から継承
├─ _salary = 0     ← Employee から継承
└─ _company = company  ← President 独自
```

**5-5. President.__init__() に戻る**

```python
self._company: 'Company' = company
```

📊 **最終的なメモリの状態:**
```
company オブジェクト
├─ _staffs = []
└─ _ceo = President オブジェクト
           ├─ _name = ""
           ├─ _salary = 0
           └─ _company = company (循環参照)
```

---

### ステップ6: 社員1の作成と設定

```python
staff1 = Staff()
```

#### 🔍 内部で起こること

**6-1. Staff.__init__() が呼ばれる**

```python
def __init__(self):
    super().__init__()  # ← Employee.__init__() を呼ぶ
    self._division: str = ""
```

**6-2. Employee.__init__() が呼ばれる**

```python
def __init__(self):
    self._name: str = ""
    self._salary: int = 0
```

📊 **メモリの状態:**
```
staff1 オブジェクト（Staff）
├─ _name = ""       ← Employee から
├─ _salary = 0      ← Employee から
└─ _division = ""   ← Staff 独自
```

**6-3. 値を設定**

```python
staff1.set_name("佐藤太郎")
```

内部処理:
```python
def set_name(self, emp_name: str):
    self._name = emp_name  # ← "佐藤太郎" を代入
```

```python
staff1.set_salary(200000)
```

内部処理:
```python
def set_salary(self, emp_salary: int):
    self._salary = emp_salary  # ← 200000 を代入
```

```python
staff1.set_division("営業部")
```

内部処理:
```python
def set_division(self, emp_division: str):
    self._division = emp_division  # ← "営業部" を代入
```

📊 **メモ
